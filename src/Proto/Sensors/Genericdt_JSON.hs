-- Code generated by protoc-gen-jsonpb_haskell 0.1.1, DO NOT EDIT.
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -Wno-orphans -Wno-unused-imports -Wno-missing-export-lists #-}
module Proto.Sensors.Genericdt_JSON where

import           Prelude(($), (.), (<$>), pure, show, Maybe(..))

import           Data.ProtoLens.Runtime.Lens.Family2 ((^.), (.~), (&))
import           Data.Monoid (mconcat)
import           Control.Monad (msum)
import           Data.ProtoLens (defMessage)
import qualified Data.Aeson as A
import qualified Data.Aeson.Encoding as E
import           Data.ProtoLens.JSONPB as JSONPB
import qualified Data.Text as T

import           Proto.Sensors.Genericdt as P
import           Proto.Sensors.Genericdt_Fields as P

instance FromJSONPB Genericopt where
  parseJSONPB = withObject "Genericopt" $ \_ -> pure defMessage

instance ToJSONPB Genericopt where
  toJSONPB _ = object []
  toEncodingPB _ = pairs []

instance FromJSON Genericopt where
  parseJSON = parseJSONPB

instance ToJSON Genericopt where
  toJSON = toAesonValue
  toEncoding = toAesonEncoding

instance FromJSONPB Genericout where
  parseJSONPB = withObject "Genericout" $ \obj -> do
    value' <- obj .: "value"
    name' <- obj .: "name"
    pure $ defMessage
      & P.value .~ value'
      & P.name .~ name'

instance ToJSONPB Genericout where
  toJSONPB x = object
    [ "value" .= (x^.value)
    , "name" .= (x^.name)
    ]
  toEncodingPB x = pairs
    [ "value" .= (x^.value)
    , "name" .= (x^.name)
    ]

instance FromJSON Genericout where
  parseJSON = parseJSONPB

instance ToJSON Genericout where
  toJSON = toAesonValue
  toEncoding = toAesonEncoding
