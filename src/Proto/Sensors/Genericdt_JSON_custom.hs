-- Code generated by protoc-gen-jsonpb_haskell 0.1.1, DO NOT EDIT.
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -Wno-orphans -Wno-unused-imports -Wno-missing-export-lists #-}
module Proto.Sensors.Genericdt_JSON_custom where

import           Prelude((/=), ($), (.), (<$>), pure, show, fst, snd, Maybe(..), flip, fromRational, realToFrac)

import           Data.ProtoLens.Runtime.Lens.Family2 ((^.), (.~), (&))
import           Data.Monoid (mconcat)
import           Control.Monad (msum, fail, when)
import           Data.ProtoLens (defMessage)
import qualified Data.Aeson as A
import qualified Data.Aeson.Encoding as E
import           Data.ProtoLens.JSONPB as JSONPB
import qualified Data.Text as T
import qualified Data.HashMap.Strict as HM
import           Proto.Sensors.Genericdt as P
import           Proto.Sensors.Genericdt_Fields as P
import qualified Data.List as L
instance FromJSONPB Genericopt where
  parseJSONPB = withObject "Genericopt" $ \_ -> pure defMessage

instance ToJSONPB Genericopt where
  toJSONPB _ = object []
  toEncodingPB _ = pairs []

instance FromJSON Genericopt where
  parseJSON = parseJSONPB

instance ToJSON Genericopt where
  toJSON = toAesonValue
  toEncoding = toAesonEncoding

instance FromJSONPB Genericout where
  parseJSONPB = withObject "Genericout" $ \obj -> do
    let keyval = HM.toList obj 
    
    when (L.length keyval /= 1) $
      fail "Incorrect number of name:value pairs"
    
    flip (A.withScientific "value") (snd . L.head $ keyval) $ 
         \s -> pure $ defMessage
               & P.value .~ realToFrac s
               & P.name .~ (fst . L.head $ keyval)

instance ToJSONPB Genericout where
  toJSONPB x = object
    [ (x^.name) .= (x^.value) ]
  toEncodingPB x = pairs
    [ (x^.name) .= (x^.value) ]

instance FromJSON Genericout where
  parseJSON = parseJSONPB

instance ToJSON Genericout where
  toJSON = toAesonValue
  toEncoding = toAesonEncoding
