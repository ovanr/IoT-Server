-- Code generated by protoc-gen-jsonpb_haskell 0.1.1, DO NOT EDIT.
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -Wno-orphans -Wno-unused-imports -Wno-missing-export-lists #-}
module Proto.Sensors.Cpudt_JSON where

import           Prelude(($), (.), (<$>), pure, show, Maybe(..))

import           Data.ProtoLens.Runtime.Lens.Family2 ((^.), (.~), (&))
import           Data.Monoid (mconcat)
import           Control.Monad (msum)
import           Data.ProtoLens (defMessage)
import qualified Data.Aeson as A
import qualified Data.Aeson.Encoding as E
import           Data.ProtoLens.JSONPB as JSONPB
import qualified Data.Text as T

import           Proto.Sensors.Cpudt as P
import           Proto.Sensors.Cpudt_Fields as P

instance FromJSONPB Cpuopt where
  parseJSONPB = withObject "Cpuopt" $ \_ -> pure defMessage

instance ToJSONPB Cpuopt where
  toJSONPB _ = object []
  toEncodingPB _ = pairs []

instance FromJSON Cpuopt where
  parseJSON = parseJSONPB

instance ToJSON Cpuopt where
  toJSON = toAesonValue
  toEncoding = toAesonEncoding

instance FromJSONPB Cpuout where
  parseJSONPB = withObject "Cpuout" $ \obj -> do
    load' <- obj .: "load"
    count' <- obj .: "count"
    pkgTemp' <- obj .: "pkgTemp"
    pure $ defMessage
      & P.load .~ load'
      & P.count .~ count'
      & P.pkgTemp .~ pkgTemp'

instance ToJSONPB Cpuout where
  toJSONPB x = object
    [ "load" .= (x^.load)
    , "count" .= (x^.count)
    , "pkgTemp" .= (x^.pkgTemp)
    ]
  toEncodingPB x = pairs
    [ "load" .= (x^.load)
    , "count" .= (x^.count)
    , "pkgTemp" .= (x^.pkgTemp)
    ]

instance FromJSON Cpuout where
  parseJSON = parseJSONPB

instance ToJSON Cpuout where
  toJSON = toAesonValue
  toEncoding = toAesonEncoding
